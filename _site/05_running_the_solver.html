<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>SPECFEM3D_Cartesian</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/assets/css/style.css?v=e01eaeac25bebaede87fee4bc75f9f27dc55c330">
  </head>
  <body>
    <section class="page-header">
      <div class="parallax"><!-- parallax -->
        <div class="parallax_layer parallax_layer_back">
          <div class="img_background img1"></div>
        </div>
      <!-- </div> -->
      <div class="parallax_layer parallax_layer_front">
        <h1 class="project-name">SPECFEM3D_Cartesian</h1>
        <h2 class="project-tagline">SPECFEM3D_Cartesian simulates acoustic (fluid), elastic (solid), coupled acoustic/elastic, poroelastic or seismic wave propagation in any type of conforming mesh of hexahedra (structured or not.)
</h2>
        
          <a href="http://github.com/danielpeter/specfem3d" class="btn">View on GitHub</a>
        
        
      </div><!-- end of parallax -->
    </section>

    <section class="main-content">
      <p><strong>Table of Contents</strong></p>

<ul>
  <li><a href="#running-the-solver-xspecfem3d">Running the Solver <code class="highlighter-rouge">xspecfem3D</code></a>
    <ul>
      <li><a href="#note-on-the-viscoelastic-model-used">Note on the viscoelastic model used</a></li>
    </ul>
  </li>
</ul>

<h1 id="running-the-solver-xspecfem3d">Running the Solver <code class="highlighter-rouge">xspecfem3D</code></h1>

<p>Now that you have successfully generated the databases, you are ready to compile the solver. In the main directory, type</p>

<div class="highlighter-rouge"><pre class="highlight"><code>make xspecfem3D
</code></pre>
</div>

<p>Please note that <code class="highlighter-rouge">xspecfem3D</code> must be called directly from the main directory, as most of the binaries of the package.</p>

<p>The solver needs three input files in the <code class="highlighter-rouge">DATA</code> directory to run:</p>

<p><span><code class="highlighter-rouge">Par_file</code></span><br />
the main parameter file which was discussed in detail in the previous Chapter [cha:Creating-Distributed-Databases],</p>

<p><span><code class="highlighter-rouge">CMTSOLUTION</code></span> or <span><code class="highlighter-rouge">FORCESOLUTION</code></span><br />
the earthquake source parameter file or the force source parameter file, and</p>

<p><span><code class="highlighter-rouge">STATIONS</code></span><br />
the stations file.</p>

<p>Most parameters in the <code class="highlighter-rouge">Par_file</code> should be set prior to running the databases generation. Only the following parameters may be changed after running <code class="highlighter-rouge">xgenerate_databases</code>:</p>

<ul>
  <li>
    <p>the simulation type control parameters: <code class="highlighter-rouge">SIMULATION_TYPE</code> and <code class="highlighter-rouge">SAVE_FORWARD</code></p>
  </li>
  <li>
    <p>the time step parameters <code class="highlighter-rouge">NSTEP</code> and <code class="highlighter-rouge">DT</code></p>
  </li>
  <li>
    <p>the absorbing boundary control parameter <code class="highlighter-rouge">PML_CONDITIONS</code> on condition that the
<code class="highlighter-rouge">PML_INSTEAD_OF_FREE_SURFACE</code> flag remains unmodified after running the databases generation.</p>
  </li>
  <li>
    <p>the movie control parameters <code class="highlighter-rouge">MOVIE_SURFACE</code>, <code class="highlighter-rouge">MOVIE_VOLUME</code>, and <code class="highlighter-rouge">NTSTEPS_BETWEEN_FRAMES</code></p>
  </li>
  <li>
    <p>the ShakeMap option <code class="highlighter-rouge">CREATE_SHAKEMAP</code></p>
  </li>
  <li>
    <p>the output information parameters <code class="highlighter-rouge">MOVIE_TYPE</code>, <code class="highlighter-rouge">NTSTEP_BETWEEN_OUTPUT_INFO</code> and
<code class="highlighter-rouge">NTSTEP_BETWEEN_OUTPUT_SEISMOS</code></p>
  </li>
  <li>
    <p>the <code class="highlighter-rouge">PRINT_SOURCE_TIME_FUNCTION</code> flags</p>
  </li>
</ul>

<p>Any other change to the <code class="highlighter-rouge">Par_file</code> implies rerunning both the database generator <code class="highlighter-rouge">xgenerate_databases</code> and the solver <code class="highlighter-rouge">xspecfem3D</code>.</p>

<p>For any particular earthquake, the <code class="highlighter-rouge">CMTSOLUTION</code> file that represents the point source may be obtained directly from the Harvard Centroid-Moment Tensor (CMT) web page . It looks like the example shown in Fig. [fig:CMTSOLUTION-file].</p>

<p><img src="figures/Hollywood_CMT.jpg" alt="`CMTSOLUTION` file based on the format from the Harvard CMT catalog. **M** is the moment tensor, (M_{0})&lt;span&gt; &lt;/span&gt;is the seismic moment, and (M_{w}) is the moment magnitude.&lt;span data-label=&quot;fig:CMTSOLUTION-file&quot;&gt;&lt;/span&gt;" /></p>
<div class="figcaption" style="text-align:justify;font-size:80%"><span style="color:#9A9A9A">Figure: `CMTSOLUTION` file based on the format from the Harvard CMT catalog. **M** is the moment tensor, \(M_{0}\)<span> </span>is the seismic moment, and \(M_{w}\) is the moment magnitude.<span data-label="fig:CMTSOLUTION-file"></span></span></div>

<p>The <code class="highlighter-rouge">CMTSOLUTION</code> file should be edited in the following way:</p>

<ul>
  <li>
    <p>Set the latitude or UTM (x) coordinate, longitude or UTM (y) coordinate, depth of the source (in km). Remark: In principle in the international CMTSOLUTION format in geophysics the depth is given in kilometers; however for users in other fields (non-destructive testing, medical imaging, near-surface studies…) who may prefer to give the position of the source (rather than its depth from the surface), or for people who use FORCESOLUTION to describe the source rather than CMTSOLUTION, we provide an option called USE_SOURCES_RECEIVERS_Z in the Par_file, and if so that position is read from CMTSOLUTION in meters rather than kilometers (and again, it is then the true position in the mesh, not the depth). When option USE_SOURCES_RECEIVERS_Z in the Par_file is on, this remark applies to the position of the receivers as well.</p>
  </li>
  <li>
    <p>Set the <code class="highlighter-rouge">time shift</code> parameter equal to (0.0) (the solver will not run otherwise.) The time shift parameter would simply apply an overall time shift to the synthetics, something that can be done in the post-processing (see Section [sec:Process-data-and-syn]).</p>
  </li>
  <li>
    <p>For point-source simulations (see finite sources, page ) we recommend setting the source half-duration parameter <code class="highlighter-rouge">half duration</code> equal to zero, which corresponds to simulating a step source-time function, i.e., a moment-rate function that is a delta function. If <code class="highlighter-rouge">half duration</code> is not set to zero, the code will use a Gaussian (i.e., a signal with a shape similar to a ‘smoothed triangle’, as explained in D. Komatitsch and Tromp (2002) and shown in Fig [fig:gauss.vs.triangle]) source-time function with half-width <code class="highlighter-rouge">half duration</code>. We prefer to run the solver with <code class="highlighter-rouge">half duration</code> set to zero and convolve the resulting synthetic seismograms in post-processing after the run, because this way it is easy to use a variety of source-time functions (see Section [sec:Process-data-and-syn]). D. Komatitsch and Tromp (2002) determined that the noise generated in the simulation by using a step source time function may be safely filtered out afterward based upon a convolution with the desired source time function and/or low-pass filtering. Use the serial code <code class="highlighter-rouge">convolve_source_timefunction.f90</code> and the script <code class="highlighter-rouge">convolve_source_timefunction.csh</code> for this purpose, or alternatively use signal-processing software packages such as SAC . Type</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>make xconvolve_source_timefunction
</code></pre>
    </div>

    <p>to compile the code and then set the parameter <code class="highlighter-rouge">hdur</code> in <code class="highlighter-rouge">convolve_source_timefunction.csh</code> to the desired half-duration.</p>
  </li>
  <li>
    <p>The zero time of the simulation corresponds to the center of the triangle/Gaussian, or the centroid time of the earthquake. The start time of the simulation is (t=-1.5*\texttt{half duration}) (the 1.5 is to make sure the moment rate function is very close to zero when starting the simulation). To convert to absolute time (t_{\mathrm{abs}}), set</p>

    <p>(t_{\mathrm{abs}}=t_{\mathrm{pde}}+\texttt{time shift}+t_{\mathrm{synthetic}})</p>

    <p>where (t_{\mathrm{pde}}) is the time given in the first line of the <code class="highlighter-rouge">CMTSOLUTION</code>, <code class="highlighter-rouge">time shift</code> is the corresponding value from the original <code class="highlighter-rouge">CMTSOLUTION</code> file and (t_{\mathrm{synthetic}}) is the time in the first column of the output seismogram.</p>
  </li>
</ul>

<p><img src="figures/gauss_vs_triangle_mod.jpg" alt="Comparison of the shape of a triangle and the Gaussian function actually used.&lt;span data-label=&quot;fig:gauss.vs.triangle&quot;&gt;&lt;/span&gt;" /></p>
<div class="figcaption" style="text-align:justify;font-size:80%"><span style="color:#9A9A9A">Figure: Comparison of the shape of a triangle and the Gaussian function actually used.<span data-label="fig:gauss.vs.triangle"></span></span></div>

<p>If you know the earthquake source in strike/dip/rake format rather than in <code class="highlighter-rouge">CMTSOLUTION</code> format, use the C code <code class="highlighter-rouge">SPECFEM3D_GLOBE/utils/strike_dip_rake_to_CMTSOLUTION.c</code> to convert it. The conversion formulas are given for instance in Aki and Richards (1980). Note that the Aki and Richards (1980) convention is slightly different from the Harvard <code class="highlighter-rouge">CMTSOLUTION</code> convention (the sign of some components is different). The C code outputs both.</p>

<p>Centroid latitude and longitude should be provided in geographical coordinates. The code converts these coordinates to geocentric coordinates (Dahlen and Tromp 1998). Of course you may provide your own source representations by designing your own <code class="highlighter-rouge">CMTSOLUTION</code> file. Just make sure that the resulting file adheres to the Harvard CMT conventions (see Appendix [cha:Coordinates]). Note that the first line in the <code class="highlighter-rouge">CMTSOLUTION</code> file is the Preliminary Determination of Earthquakes (PDE) solution performed by the USGS NEIC, which is used as a seed for the Harvard CMT inversion. The PDE solution is based upon P waves and often gives the hypocenter of the earthquake, i.e., the rupture initiation point, whereas the CMT solution gives the ‘centroid location’, which is the location with dominant moment release. The PDE solution is not used by our software package but must be present anyway in the first line of the file.</p>

<p>[To-simulate-a]To simulate a kinematic rupture, i.e., a finite-source event, represented in terms of (N_{\mathrm{sources}}) point sources, provide a <code class="highlighter-rouge">CMTSOLUTION</code> file that has (N_{\mathrm{sources}}) entries, one for each subevent (i.e., concatenate (N_{\mathrm{sources}}) <code class="highlighter-rouge">CMTSOLUTION</code> files to a single <code class="highlighter-rouge">CMTSOLUTION</code> file). At least one entry (not necessarily the first) must have a zero <code class="highlighter-rouge">time shift</code>, and all the other entries must have non-negative <code class="highlighter-rouge">time shift</code>. Each subevent can have its own half duration, latitude, longitude, depth, and moment tensor (effectively, the local moment-density tensor).</p>

<p>Note that the zero in the synthetics does NOT represent the hypocentral time or centroid time in general, but the timing of the <em>center</em> of the source triangle with zero <code class="highlighter-rouge">time shift</code> (Fig [fig:source<sub>t</sub>iming]).</p>

<p>Although it is convenient to think of each source as a triangle, in the simulation they are actually Gaussians (as they have better frequency characteristics). The relationship between the triangle and the gaussian used is shown in Fig [fig:gauss.vs.triangle]. For finite fault simulations it is usually not advisable to use a zero half duration and convolve afterwards, since the half duration is generally fixed by the finite fault model.</p>

<p>The <code class="highlighter-rouge">FORCESOLUTION</code> file should be edited in the following way:</p>

<ul>
  <li>
    <p>Set the <code class="highlighter-rouge">time shift</code> parameter equal to (0.0) (the solver will not run otherwise.) The time shift parameter would simply apply an overall time shift to the synthetics, something that can be done in the post-processing (see Section [sec:Process-data-and-syn]).</p>
  </li>
  <li>
    <p>Set the <code class="highlighter-rouge">f0</code> parameter (the dominant frequency) of the Ricker source time function (i.e., the second derivative of a Gaussian) when <span><code class="highlighter-rouge">USE_RICKER_TIME_FUNCTION</code></span> is turned on in the main parameter file <span><code class="highlighter-rouge">Par_file</code></span>. In case that the solver uses a (pseudo) Dirac delta source time function to represent a force point source, a very short duration of five time steps is automatically set by default. Note that we use the standard definition of a Ricker, for a dominant frequency (f_0): (\mathrm{Ricker}(t) = (1 - 2 a t^2) e^{-a t^2}), with (a = \pi^2 f_0^2), whose Fourier transform is thus: (\frac{1}{2} \frac{\sqrt{\pi}\omega^2}{a^{3/2}}e^{-\frac{\omega^2}{4 a}}) This gives the wavelet of Figure [fig:RickerWavelet].</p>
  </li>
  <li>
    <p>Set the latitude or UTM (x) coordinate, longitude or UTM (y) coordinate, depth of the source (in km).</p>
  </li>
  <li>
    <p>Set the magnitude of the force source.</p>
  </li>
  <li>
    <p>Set the components of a (non-unitary) direction vector for the force source in the East/North/Vertical basis (see Appendix A for the orientation of the reference frame).</p>
  </li>
</ul>

<p>Where necessary, set a <code class="highlighter-rouge">FORCESOLUTION</code> file in the same way you configure a <code class="highlighter-rouge">CMTSOLUTION</code> file with (N_{\mathrm{sources}}) entries, one for each subevent (i.e., concatenate (N_{\mathrm{sources}}) <code class="highlighter-rouge">FORCESOLUTION</code> files to a single <code class="highlighter-rouge">FORCESOLUTION</code> file). At least one entry (not necessarily the first) must have a zero <code class="highlighter-rouge">time shift</code>, and all the other entries must have non-negative <code class="highlighter-rouge">time shift</code>. Each subevent can have its own half latitude, longitude, depth, <code class="highlighter-rouge">half duration</code> and force parameters.</p>

<p><img src="figures/source_timing.jpg" alt="Example of timing for three sources. The center of the first source triangle is defined to be time zero. Note that this is NOT in general the hypocentral time, or the start time of the source (marked as tstart). The parameter `time shift` in the `CMTSOLUTION` file would be t1(=0), t2, t3 in this case, and the parameter `half duration` would be hdur1, hdur2, hdur3 for the sources 1, 2, 3 respectively." /></p>
<div class="figcaption" style="text-align:justify;font-size:80%"><span style="color:#9A9A9A">Figure: Example of timing for three sources. The center of the first source triangle is defined to be time zero. Note that this is NOT in general the hypocentral time, or the start time of the source (marked as tstart). The parameter `time shift` in the `CMTSOLUTION` file would be t1(=0), t2, t3 in this case, and the parameter `half duration` would be hdur1, hdur2, hdur3 for the sources 1, 2, 3 respectively.</span></div>

<p><span>[fig:source<sub>t</sub>iming] </span></p>

<p>In addition to inbuild source time function, the solver can also use an external source time function defined by the user. This option can be activated by setting <code class="highlighter-rouge">EXTERNAL_SOURCE_FILE</code> to true in <code class="highlighter-rouge">Par_File</code> and by adding the name of the file containing the source time function at the end of <code class="highlighter-rouge">FORCESOLUTION</code> or <code class="highlighter-rouge">CMTSOLUTION</code> files. The source time function file must contain the value of the time step on its first line, and then a single column with the amplitude of the source time function for all the time steps. The time step must be exactly the same as that used for the simulation. Note when the <code class="highlighter-rouge">EXTERNAL_SOURCE_FILE</code> is set to false then the line with the external source time function file must not appear in the files <code class="highlighter-rouge">FORCESOLUTION</code> and <code class="highlighter-rouge">CMTSOLUTION</code> otherwise the solver will exit with an error. When using an external source file, you can still set up the source location and directivity as in the default case. In the FORCESOLUTION file: you set “latorUTM”, “longorUTM” and “depth” to define the position of your point source. Then if you want to define a directivity, then change the following lines: “component dir vect source E”, “component dir vect source N” and “component dir vect source Z_UP”. What you are doing is simply that you define the source position and directivity the same way as in the default case, but in addition you are specifying the path to read in a non-default source time function from an external file.</p>

<p>The solver can calculate seismograms at any number of stations for basically the same numerical cost, so the user is encouraged to include as many stations as conceivably useful in the <code class="highlighter-rouge">STATIONS</code> file, which looks like this:</p>

<p><img src="figures/STATIONS_basin_explained.jpg" alt="Sample `STATIONS` file. Station latitude and longitude should be provided in geographical coordinates. The width of the station label should be no more than 32 characters (see `MAX_LENGTH_STATION_NAME` in the `constants.h` file), and the network label should be no more than 8 characters (see `MAX_LENGTH_NETWORK_NAME` in the `constants.h` file).&lt;span data-label=&quot;fig:Sample-STATIONS-file.&quot;&gt;&lt;/span&gt;" /></p>
<div class="figcaption" style="text-align:justify;font-size:80%"><span style="color:#9A9A9A">Figure: Sample `STATIONS` file. Station latitude and longitude should be provided in geographical coordinates. The width of the station label should be no more than 32 characters (see `MAX_LENGTH_STATION_NAME` in the `constants.h` file), and the network label should be no more than 8 characters (see `MAX_LENGTH_NETWORK_NAME` in the `constants.h` file).<span data-label="fig:Sample-STATIONS-file."></span></span></div>

<p>Each line represents one station in the following format:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Station Network Latitude(degrees) Longitude(degrees) Elevation(m) burial(m)
</code></pre>
</div>

<p>The solver <code class="highlighter-rouge">xspecfem3D</code> filters the list of stations in file <code class="highlighter-rouge">DATA/STATIONS</code> to exclude stations that are not located within the region given in the <code class="highlighter-rouge">Par_file</code> (between <code class="highlighter-rouge">LATITUDE_MIN</code> and <code class="highlighter-rouge">LATITUDE_MAX</code> and between <code class="highlighter-rouge">LONGITUDE_MIN</code> and <code class="highlighter-rouge">LONGITUDE_MAX</code>). The filtered file is called <code class="highlighter-rouge">DATA/STATIONS_FILTERED</code>.</p>

<p>Elevation and burial are generally applicable to geographical regions. Burial is measured down from the top surface. For other problems in other fields (ultrasonic testing, medical imaging etc…), it may be confusing. We generally follow either of the following procedures for those kind of problems:</p>

<h1 id="procedure-1-mostly-for-geophysics-when-the-top-surface-is-a-free-surface-topography-and-the-five-other-edges-of-the-mesh-are-absorbing-surfaces">Procedure 1 (mostly for geophysics, when the top surface is a free surface (topography) and the five other edges of the mesh are absorbing surfaces):</h1>

<ul>
  <li>
    <p>Put the origin on the top of the model.</p>
  </li>
  <li>
    <p>Let’s say you want to place two receivers at (x1,y1,z1) and (x2,y2,z2). Your STATIONS file should look like:</p>
  </li>
</ul>

<p>BONE GR y1 x1 0.00 -z1
BONE GR y2 x2 0.00 -z2</p>

<h1 id="procedure-2-useful-for-other-application-domains-in-which-using-the-absolute-z-position-of-the-sources-and-receivers-is-more-standard-than-using-their-depth-from-the-surface">Procedure 2 (useful for other application domains, in which using the absolute (Z) position of the sources and receivers is more standard than using their depth from the surface):</h1>

<ul>
  <li>
    <p>In principle in the international CMTSOLUTION format in geophysics the depth is given in kilometers; however for users in other fields (non-destructive testing, medical imaging, near-surface studies…) who may prefer to give the position of the source (rather than its depth from the surface), or for people who use FORCESOLUTION to describe the source rather than CMTSOLUTION, we provide an option called USE_SOURCES_RECEIVERS_Z in the Par_file, and if so that position is read from CMTSOLUTION in meters rather than kilometers (and again, it is then the true position in the mesh, not the depth). When option USE_SOURCES_RECEIVERS_Z in the Par_file is on, this remark applies to the position of the receivers as well.</p>
  </li>
  <li>
    <p>Let’s say you want to place two receivers at (x1,y1,z1) and (x2,y2,z2). Your STATIONS file should then look like:
BONE GR y1 x1 0.00 z1
BONE GR y2 x2 0.00 z2
The option USE_SOURCES_RECEIVERS_Z set to .true. will then discard the elevation and set burial as the (z) coordinate.
Third column is Y and Fourth is X due to the latitude/longitude convention.
You can replace the station name “BONE” with any word of length less than 32, and the network name “GR” with any word of length less than 8.
You can always plot OUTPUT_FILES/sr.vtk file in ParaView to check the source/receiver locations after your simulation.</p>
  </li>
</ul>

<p>Solver output is provided in the <code class="highlighter-rouge">OUTPUT_FILES</code> directory in the <code class="highlighter-rouge">output_solver.txt</code> file. Output can be directed to the screen instead by uncommenting a line in <code class="highlighter-rouge">constants.h</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>! uncomment this to write messages to the screen
! integer, parameter :: IMAIN = ISTANDARD_OUTPUT
</code></pre>
</div>

<p>On PC clusters the seismogram files are generally written to the local disks (the path <code class="highlighter-rouge">LOCAL_PATH</code> in the <code class="highlighter-rouge">Par_file</code>) and need to be gathered at the end of the simulation.</p>

<p>While the solver is running, its progress may be tracked by monitoring the ‘<code class="highlighter-rouge">timestamp*</code>’ files in the <code class="highlighter-rouge">OUTPUT_FILES/</code> directory. These tiny files look something like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Time step #          10000
Time:     108.4890      seconds
Elapsed time in seconds =    1153.28696703911
Elapsed time in hh:mm:ss =     0 h 19 m 13 s
Mean elapsed time per time step in seconds =     0.115328696703911
Max norm displacement vector U in all slices (m) =     1.0789589E-02
</code></pre>
</div>

<p>The <code class="highlighter-rouge">timestamp*</code> files provide the <code class="highlighter-rouge">Mean elapsed time per time step in seconds</code>, which may be used to assess performance on various machines (assuming you are the only user on a node), as well as the <code class="highlighter-rouge">Max norm displacement vector U in all slices (m)</code>. If something is wrong with the model, the mesh, or the source, you will see the code become unstable through exponentially growing values of the displacement and fluid potential with time, and ultimately the run will be terminated by the program. You can control the rate at which the timestamp files are written based upon the parameter <code class="highlighter-rouge">NTSTEP_BETWEEN_OUTPUT_INFO</code> in the <code class="highlighter-rouge">Par_file</code>.</p>

<p>Having set the <code class="highlighter-rouge">Par_file</code> parameters, and having provided the <code class="highlighter-rouge">CMTSOLUTION</code> (or the <code class="highlighter-rouge">FORCESOLUTION</code>) and <code class="highlighter-rouge">STATIONS</code> files, you are now ready to launch the solver! This is most easily accomplished based upon the <code class="highlighter-rouge">go_solver</code> script (See Chapter [cha:Scheduler] for information about running through a scheduler, e.g., LSF). You may need to edit the last command at the end of the script that invokes the <code class="highlighter-rouge">mpirun</code> command. The <code class="highlighter-rouge">runall</code> script compiles and runs both <code class="highlighter-rouge">xgenerate_databases</code> and <code class="highlighter-rouge">xspecfem3D</code> in sequence. This is a safe approach that ensures using the correct combination of distributed database output and solver input.</p>

<p>It is important to realize that the CPU and memory requirements of the solver are closely tied to choices about attenuation (<code class="highlighter-rouge">ATTENUATION</code>) and the nature of the model (i.e., isotropic models are cheaper than anisotropic models). We encourage you to run a variety of simulations with various flags turned on or off to develop a sense for what is involved.</p>

<p>For the same model, one can rerun the solver for different events by simply changing the <code class="highlighter-rouge">CMTSOLUTION</code> or <code class="highlighter-rouge">FORCESOLUTION</code> file, or for different stations by changing the <code class="highlighter-rouge">STATIONS</code> file. There is no need to rerun the <code class="highlighter-rouge">xgenerate_databases</code> executable. Of course it is best to include as many stations as possible, since this does not add to the cost of the simulation.</p>

<p>We have also added the ability to run several calculations (several earthquakes) in an embarrassingly-parallel fashion from within the same run; this can be useful when using a very large supercomputer to compute many earthquakes in a catalog, in which case it can be better from a batch job submission point of view to start fewer and much larger jobs, each of them computing several earthquakes in parallel. To turn that option on, set parameter <code class="highlighter-rouge">NUMBER_OF_SIMULTANEOUS_RUNS</code> to a value greater than 1 in file setup/constants.h.in before configuring and compiling the code. When that option is on, of course the number of processor cores used to start the code in the batch system must be a multiple of <code class="highlighter-rouge">NUMBER_OF_SIMULTANEOUS_RUNS</code>, all the individual runs must use the same number of processor cores, which as usual is <code class="highlighter-rouge">NPROC</code> in the input file <code class="highlighter-rouge">DATA/Par_file</code>, and thus the total number of processor cores to request from the batch system should be <code class="highlighter-rouge">NUMBER_OF_SIMULTANEOUS_RUNS \times NPROC</code>. All the runs to perform must be placed in directories called <code class="highlighter-rouge">run0001</code>, <code class="highlighter-rouge">run0002</code>, <code class="highlighter-rouge">run0003</code> and so on (with exactly four digits) and you must create a link from the root directory of the code to the first copy of the executable programs by typing <code class="highlighter-rouge">ln -s run0001/bin bin</code>.</p>

<h2 id="note-on-the-viscoelastic-model-used">Note on the viscoelastic model used</h2>

<p>The model used is a constant (Q), thus with no dependence on frequency ((Q(f)) = constant). See e.g. Blanc et al. (2016).</p>

<p>However in practice for technical reasons it is approximated based on the sum of different Generalized Zener body mechanisms and thus the code outputs the band in which the approximation is very good, outside of that range it can be less accurate. The logarithmic center of that frequency band is the <code class="highlighter-rouge">ATTENUATION_f0</code> parameter defined (in Hz) in input file <code class="highlighter-rouge">DATA/Par_file</code>.</p>

<p>Regarding attenuation (viscoelasticity), in the Par_file you need to select the number of standard linear solids (N_SLS) to use to mimic a constant (Q) quality factor. Using N_SLS = 3 is always safe. If (and only if) you know what you are doing, you can try to reduce that in order to reduce the cost of the simulations. Figure [fig:selectNSLS] shows values that you can consider using (again, if and only if you know what you are doing). That table has been created by Zhinan Xie using a comparison between results obtained with a truly-constant (Q) and results obtained with its approximation based on N_SLS standard linear solids. The comparison is performed using the time-frequency misfit and goodness-of-fit criteria proposed by Kristeková, Kristek, and Moczo (2009). The table is drawn for a dimensionless parameter representing the distance of propagation.</p>

<p><img src="figures/minimum_number_of_SLS_that_can_be_used_in_viscoelastic_simulation.png" alt="Table showing how you can select a value of N_SLS smaller than 3, if and only if you know what you are doing.&lt;span data-label=&quot;fig:selectNSLS&quot;&gt;&lt;/span&gt;" /></p>
<div class="figcaption" style="text-align:justify;font-size:80%"><span style="color:#9A9A9A">Figure: Table showing how you can select a value of N\_SLS smaller than 3, if and only if you know what you are doing.<span data-label="fig:selectNSLS"></span></span></div>

<h2 id="references">References</h2>

<p>Aki, K., and P. G. Richards. 1980. <em>Quantitative Seismology, Theory and Methods</em>. San Francisco, USA: W. H. Freeman.</p>

<p>Blanc, Émilie, Dimitri Komatitsch, Emmanuel Chaljub, Bruno Lombard, and Zhinan Xie. 2016. “Highly Accurate Stability-Preserving Optimization of the Zener Viscoelastic Model, with Application to Wave Propagation in the Presence of Strong Attenuation.” <em>Geophys. J. Int.</em> 205 (1): 427–39. doi:<a href="http://dx.doi.org/10.1093/gji/ggw024">10.1093/gji/ggw024</a>.</p>

<p>Dahlen, F. A., and J. Tromp. 1998. <em>Theoretical Global Seismology</em>. Princeton, New-Jersey, USA: Princeton University Press.</p>

<p>Komatitsch, D., and J. Tromp. 2002. “Spectral-Element Simulations of Global Seismic Wave Propagation-I. Validation.” <em>Geophys. J. Int.</em> 149 (2): 390–412. doi:<a href="http://dx.doi.org/10.1046/j.1365-246X.2002.01653.x">10.1046/j.1365-246X.2002.01653.x</a>.</p>

<p>Kristeková, Miriam, Jozef Kristek, and Peter Moczo. 2009. “Time-Frequency Misfit and Goodness-of-Fit Criteria for Quantitative Comparison of Time Signals.” <em>Geophys. J. Int.</em> 178 (2): 813–25. doi:<a href="http://dx.doi.org/10.1111/j.1365-246X.2009.04177.x">10.1111/j.1365-246X.2009.04177.x</a>.</p>

<hr />
<blockquote>
  <p>This documentation has been automatically generated by <a href="http://www.pandoc.org">pandoc</a>
based on the User manual (LaTeX version) in folder doc/USER_MANUAL/
(Mar 10, 2020)</p>
</blockquote>


    </section>

    <section class="page-footer">
      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="http://github.com/danielpeter/specfem3d">specfem3d</a> is maintained by <a href="http://github.com/danielpeter">danielpeter</a></span>
        
        <span class="site-footer-credits">generated by <a href="https://pages.github.com">GitHub Pages</a></span>
      </footer>
    </section>

    
  </body>
</html>
